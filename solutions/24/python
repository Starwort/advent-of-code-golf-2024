import re
from functools import*
from itertools import*

i,g=open(0).read().split("\n\n")
f={}
for l in i.split("\n"):m=re.search(r"([xy]\d\d): ([10])",l);x,v=m.groups();v=int(v);f[x]=v
ops=set()
O=[]
for l in g.split("\n"):
 m=re.search(r"([a-z0-9]{3}) ([XORAND]+) ([a-z0-9]{3}) -> ([a-z0-9]{3})",l)
 x1,op,x2,r=m.groups()
 ops.add((x1,x2,r,op))
 O.append((x1,x2,r,op))
p={}
o_map={}
for x1,x2,r,op in ops:
 p[r]=(x1,x2)
 o_map[r]=op
@cache
def d(r):
 if r in f:return 0
 assert r in p
 x1,x2=p[r]
 return max(d(x1),d(x2))+1
v=[(r,d(r)) for _,_,r,_ in ops]
v.sort(key=lambda x:x[1])
for r,_ in v:
 assert r in p
 x1,x2=p[r]
 v1,v2=f[x1],f[x2]
 op=o_map[r]
 val={"XOR":lambda a,b:a^b,"OR":lambda a,b:a|b,"AND":lambda a,b:a&b,}[op](v1,v2)
 f[r]=val
rgs=list(f.items())
rgs.sort(key=lambda x:x[0])
n_out=int(str(rgs[-1][0])[-2:])+1
def fm(O):
 ops={}
 for x1,x2,r,op in O:ops[(frozenset([x1,x2]),op)]=r
 def get_res(x1,x2,op):return ops.get((frozenset([x1,x2]),op),None)
 c={}
 correct=set()
 prev=set()
 for i in range(45):
  p=f"0{i}"if i<10 else str(i)
  pd=get_res(f"x{p}",f"y{p}","XOR")
  pc1=get_res(f"x{p}",f"y{p}","AND")
  if i==0:
   assert pd==f"z00"
   c[i]=pc1
   continue
  d=get_res(c[i-1],pd,"XOR")
  if d!=f"z{p}":return i-1,correct
  correct.add(c[i-1])
  correct.add(pd)
  for w in prev:correct.add(w)
  pc2=get_res(c[i-1],pd,"AND")
  co=get_res(pc1,pc2,"OR")
  c[i]=co
  prev={pc1,pc2}
 return 45,correct
s=set()
b,b_used=fm(O)
for _ in range(4):
 for i,j in combinations(range(len(O)),2):
  x1_i,x2_i,r_i,op_i=O[i]
  x1_j,x2_j,r_j,op_j=O[j]
  if "z00" in(r_i,r_j):continue
  if r_i in b_used or r_j in b_used:continue
  O[i]=x1_i,x2_i,r_j,op_i
  O[j]=x1_j,x2_j,r_i,op_j
  a,a_used=fm(O)
  if a>b:
   s.add((r_i,r_j))
   b,b_used=a,a_used
   break
  O[i]=x1_i,x2_i,r_i,op_i
  O[j]=x1_j,x2_j,r_j,op_j
print(int("".join(str(val)for _,val in rgs[-n_out:])[::-1],2),",".join(sorted(sum(s,start=tuple()))))